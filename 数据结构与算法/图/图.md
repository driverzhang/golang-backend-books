## 开篇问题：

#### 1. 我们如何存储微博、微信、QQ 等社交网络中的好友关系？

#### 2. 给你一个用户，如何找出这个用户的所有三度（其中包含一度、二度和三度）好友关系？

解决些个问题，我们其实引入数据结构就是 “图”。 

先介绍关于图得存储。

# 一. 图数据结构介绍：

首先树是一种非线性结构，而 **图（Graph）** 则是一个更为复杂的非线性结构。


- 顶点：对比树种的元素成为节点，图中的元素则称为 **顶点**。

- 边：图中的 一个顶点 到另外任意一个顶点 之间的边，我们称为 **边（edge）** 。

![图](https://static001.geekbang.org/resource/image/df/af/df85dc345a9726cab0338e68982fd1af.jpg)


## 对应实际社交关系对比：

- 度：每个用户就是一个顶点，其中，每个用户有多少个好友，对应就叫做 顶点的 **度**，就是跟顶点相连接的边的条数。
- ### 微信： 假设我们任务微信就是双边关系，即你关注我的同时我也关注了你。

对应的图得关系如下：

![图](https://static001.geekbang.org/resource/image/df/af/df85dc345a9726cab0338e68982fd1af.jpg)

- ### 微博： 微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博是允许单向关注的。

对应图如下：

![](https://static001.geekbang.org/resource/image/c3/96/c31759a37d8a8719841f347bd479b796.jpg)

引入方向关系，A 关注了B 就从A一条线指向B；如果同时B也关注了A，则B也画一条线指向A。

这种边有方向的图叫作“有向图”，反之没有方向“无向图”。

无向图 => 度（表示一个顶点有多少条边） 

有向图 => 入度（表示有多少条边指向这个顶点；微博中代表有多少粉丝数量） 和 出度（表示有多少条边是以这个顶点为起点指向其他顶点，微博中代表你的关注的人数量）

- ### QQ：QQ我们假定是无向的，但是它有个功能叫做“QQ 亲密度”。

QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。

![](https://static001.geekbang.org/resource/image/55/e8/55d7e4806dc47950ae098d959b03ace8.jpg)

带权图: 在带权图中，每条边都有一个权重（weight），我们可以通过这个权重来表示 QQ 好友间的亲密度。

---

# 二. 在内存中存储图这种数据结构：

两种方法存储：

- 邻接矩阵存储方法
- 邻接表存储方法


## 邻接矩阵存储方法

邻接矩阵的底层依赖一个二维数组。

对于无向图：顶点i 和 顶点 j 有边，就把A[i][j] 和 A[j][i] 在矩阵中的位置对于标记为1。

对于有向图：顶点i 指向 顶点j 则A[i][j] 标记为1。 相反同理标1

对于带权图无向图：对无向图标记方法一样，只是标记为对于的权重值即可。


![](https://static001.geekbang.org/resource/image/62/d2/625e7493b5470e774b5aa91fb4fdb9d2.jpg)

缺点：

由上图我们可以观察 其实他们都是对按照对角数据都是对称的，但是要根据顶点的个数n添加矩阵数为n * n的大小。

邻接矩阵来表示一个图，虽然简单、直观，但是比较浪费存储空间。

> 存储的如果是稀疏图（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那邻接矩阵的存储方法就更加浪费空间了。比如微信有好几亿的用户，对应到图上就是好几亿的顶点。但是每个用户的好友并不会很多，一般也就三五百个而已。如果我们用邻接矩阵来存储，那绝大部分的存储空间都被浪费了

优点：

首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以在获取两个顶点的关系时，就非常高效。

其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，可以将很多图的运算转换成矩阵之间的运算。




## 邻接表存储方法

这个方法对于的数据结构有点类似 哈希表：

![](https://static001.geekbang.org/resource/image/03/94/039bc254b97bd11670cdc4bf2a8e1394.jpg)

每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点。

每个顶点对应的链表里面，存储的是该顶点中所有指向的顶点。

> 邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。


> 在基于链表法解决冲突的散列表中，如果链过长，为了提高查找效率，我们可以将链表换成其他更加高效的数据结构，比如平衡二叉查找树等



---

# 三. 解答开篇1：

数据结构是为算法服务的，所以具体选择哪种存储方法，与期望支持的操作有关系。

针对微博用户关系，我们的基本需求如下：

- 判断用户 A 是否关注了用户 B；
- 判断用户 A 是否是用户 B 的粉丝；
- 用户 A 关注用户 B；
- 用户 A 取消关注用户 B；
- 根据用户名称的首字母排序，分页获取用户的粉丝列表；
- 根据用户名称的首字母排序，分页获取用户的关注列表。

为了实现上面的需求，我们需要额外建立一个 “逆领表”，邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系

邻接表中，每个顶点的链表中，存储的就是这个顶点指向的顶点；

逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点。

![](https://static001.geekbang.org/resource/image/50/a1/501440bcffdcf4e6f9a5ca1117e990a1.jpg)

现在再来考虑两个问题：

1. 我们需要快速判断两个用户之间是否关注与被关注，应该将查询低效的链表结构换掉。
2. 我们还需要支持用户字母分页获取对应相关列表。

综上所述： **跳表** 是一个很好的选择，实现简单空间复杂度稍微高一点，跳表插入、删除、查找都非常高效，时间复杂度是 O(logn)，空间复杂度上稍高，是 O(n)。

跳表中存储的数据本来就是有序（最底层是一个有序的链表结构）的了，分页获取粉丝列表或关注列表，就非常高效。


3. 我们考虑前期数据用户量小可以直接将整个社交关系存在内存中，以便于进行快速操作。但是数据达到上亿，如果处理：

方案1：哈希算法等数据分片方式，将邻接表存储在不同的机器上（分布式内存）。

![](https://static001.geekbang.org/resource/image/08/2f/08e4f4330a1d88e9fec94b0f2d1bbe2f.jpg)


方案2： 直接放进数据库吧。

![](https://static001.geekbang.org/resource/image/73/8f/7339595c631660dc87559bec2ddf928f.jpg)

两列都建立索引。

## 小结：

图是非线性数据结构。

包括了： 有向图、无向图、带权图。顶点、边、度、入度、出度

两种存储方式： 邻接矩阵和邻接表。

邻接矩阵存储方法的缺点是比较浪费空间，但是优点是查询效率高，而且方便矩阵运算。

邻接表存储方法中每个顶点都对应一个链表，存储与其相连接的其他顶点。尽管邻接表的存储方式比较节省存储空间，但链表不方便查找，所以查询效率没有邻接矩阵存储方式高。（换跳表即可）


---

## 参考：

[图的表示：如何存储微博、微信等社交网络中的好友关系？](https://time.geekbang.org/column/article/70537)

[深度和广度优先搜索：如何找出社交网络中的三度好友关系？](https://time.geekbang.org/column/article/70891)